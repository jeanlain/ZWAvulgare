##%######################################################%##
#                                                          #
####      some functions used in the other scripts      ####
#                                                          #
##%######################################################%##

# this script is sourced but the others as necessary

require(data.table)
require(matrixStats)
require(stringi)
library(parallel)


# some generic data manipulation functions ---------------------

matchLast = function(x, table, ...) {			
  # like match, but returns the last position of each element of x in vect
  if(is.character(x)) {
    return(length(table)+1L - chmatch(x, rev(table), ...))
  } else return(length(table)+1L - match(x, rev(table), ...))
}


mids <- function(v) {
  # computes the mid value between successive elements of a numeric vector
  i <- 2:length(v)
  (v[i - 1L] + v[i]) / 2L
}


readNamedVector <- function(file, nameCol = 1, valueCol = nameCol + 1, ...) {
  # reads a multi-column file and makes one colone (the second, by default) the
  # values of vector, and the first column, the names of the vector. Other
  # columns are ignored. nameCol is the number of the column containing names
  dt <- fread(file, ..., data.table = F)
  vect <- dt[, valueCol]
  setNames(vect, dt[, nameCol])
}


writeT <- function(data, path, ...) {
  # convenience function to write a data.table to disk with commonly used settings

  fwrite(
    data,
    path,
    quote = F,
    row.names = F,
    na = "NA",
    sep = "\t",
    ...
  )
}


toInteger <- function(string,
                      sorted = F,
                      unique = T) {
  # turns a string vector into integers

  if (is.numeric(string)) {
    return(string)
  } else {
    if (unique) {
      u <- unique(string)
    } else {
      u <- string
    }
    if (sorted) {
      u <- sort(u)
    }
    return(chmatch(string, u))
  }
}



splitToColumns <- function(vect,
                           split,
                           columns,
                           empty = "",
                           mode = "character") {
  # splits a character vector and returns a matrix. Characters are split upon each
  # occurence of the split argument (a character of length one). empty defines
  # what the empty cell should be, and mode is the mode of the returned matrix.
  # This basically does what stri_split_fixed() does, but may sometimes be more
  # convenient or faster

  vect <- as.character(vect)
  nc <- stri_length(split)
  out <- NULL

  if (!missing(columns)) {
    cols <- as.integer(columns)
    cols <- cols[cols >= 1]
    out <- matrix(empty, length(vect), length(cols))
  } else {
    cols <- 1:1000
  }

  col <- 1

  repeat {
    temp <- vect
    pos <- as.vector(regexpr(split, vect, fixed = T)) - 1
    f <- pos >= 0
    temp[f] <- stri_sub(vect[f], 0, pos[f])

    if (!missing(columns)) {
      if (col %in% cols) {
        out[, match(col, cols)] <- temp
      }
    } else {
      out <- cbind(out, temp)
    }

    col <- col + 1

    if (col > max(cols) | !any(f)) {
      break
    }

    vect[f] <- stri_sub(vect[f], pos[f] + nc + 1, stri_length(vect[f]))
    vect[!f] <- empty
  }

  if (ncol(out) == 1) {
    out <- as.vector(out)
  }

  storage.mode(out) <- mode

  out
}



# functions specific to the SNP analysis ---------------------

baseMatrix <- function(scannedBam, genomePos, minMapQ = 1L, onlyProper = F) {
  # this function counts the number of read covering each base from a data.table "scannedBam" generated by scanBamAtPositions.R
  # it returns a 4 column matrix where each line is a position and a column a base (in ACGT order)
  # each cell is the number of read carrying the base (hence could be 0)
  # genomePos is the absolute genomic position for which we want the bases
  # minMapQ is the minimum mapping quality to consider a read
  # onlyProper tells if we should only consider reads mapped in proper pairs

  # we optain all the genomic positions in the table
  uPos <- unique(scannedBam$pos)

  if (onlyProper) {

    # We encode the combination of a position and a given base type (column V3)
    # into a number that goes from n+1 (Adenine) to n+4 (Thymine) for each
    # position. Tabulating this number effectively counts the number of times
    # each base is seen at each position
    counts <- scannedBam[mapq >= minMapQ, tabulate(
      match(pos, uPos) * 4L - 4L + base,
      nbins = length(uPos) * 4L
    )]
  } else {
    # not being in proper pair is encoded as mapQ < 0
    counts <- scannedBam[abs(mapq) >= minMapQ, tabulate(
      match(pos, uPos) * 4L - 4L + base,
      nbins = length(uPos) * 4L
    )]
  }

  # we put the base counts for the same position in the same line. Rows in
  # this matrix correspond to positions in uPos
  counts <- matrix(counts, ncol = 4, byrow = T)

  # now they correspond to the genomic positions in the original vcf
  counts <- counts[match(genomePos, uPos), ]
  counts[is.na(counts)] <- 0L
  cat("*")
  counts
}


# the possible values of f in our pools (of n = 10)
Fset <- 0:10 / 20

countReads <- function(F1scan, snps, minMapq = 20L, nCont, saveForSimu = T, pool) {
  # retrieves the c1, r1, c2 and r2 for a pool (F1scan data.table)
  # snps is a data.table indicating position, alleles and group for each retained SNP
  # nCont is the number of contigs (needed for some instructions)
  # pool is the name of the pool being processed (only used to name a file)
  # see script 03 to know why we use c1, c2, etc. instead of cw, czâ€¦ and what a
  # "SNP group" means

  # we first select the data we need for the given pool (read id, position and base)
  F1scan <- F1scan[abs(mapq) >= minMapq, .(readPair, pos, base)]

  # we also convert the genomic positions into a smaller integers
  # which correspond to the row index in the snps table. This will speed things up
  F1scan[, pos := match(pos, snps$genomePos)]
  
  # and we remove positions that do not correspond to retained SNPs
  F1scan <- F1scan[!is.na(pos)]
  
  # we assign position to contigs (contigs were dropped in the F1 bam scan to save space)
  # .bincode makes it so that the contig correspond to a number of the uContigs vector
  F1scan[, contig := snps[pos, CHROM]]

  # we only retain reads whose bases correspond to parental alleles
  F1scan <- F1scan[base == snps[pos, A1] | base == snps[pos, A2]]

  # we need to avoid duplicates in read pair identifiers
  # as the same identifier can designate reads that were scanned in different bins
  # in scanBamAtPositions.R. To avoid that, we associate the contig id to the read pair id
  F1scan[, readPair := readPair * 100000 + contig]
  
  # and convert the result to smaller integers
  F1scan[, readPair := match(readPair, unique(readPair))]
  
  if (saveForSimu) {
    # we take this opportunity to save data used in the future simulations
    if(!dir.exists("simu")) dir.create("simu")
    saveRDS(F1scan[, -"base"], stri_c("simu/", pool, ".reads.RDS"), compress = F)
  }

  # we now count the reads carrying the different alleles for the different SNP groups
  readCount <- F1scan[, .(contig = 1:nCont, count = tabulate(contig[!duplicated(readPair)], nbins = nCont)),
                      by = .(group = snps[pos, group], maternal = base == snps[pos, A1])]
  
  # in the dcast below, r1 and r2 will initially count the reads carrying paternal alleles
  readCount <- dcast(readCount, contig ~ ifelse(maternal, "c", "r") + group, value.var = "count", sep = "", fill = 0L)

  # while they should correspond to reads carrying maternal + paternal alleles
  readCount[, c("r1", "r2") := .(c1 + r1, c2 + r2)]

  # we reorder columns, as we prefer having r1 next to c1, etc.
  setcolorder(readCount, c("contig", "c1", "r1", "c2", "r2"))

  # this creates NAs for contigs lacking SNPs, we replace them with zeros
  readCount[is.na(contig), c("c1", "r1", "c2", "r2") := 0L]
  cat(".")

  # we don't return the "contig" column, as it will be the same for all pools
  readCount[, -"contig"]
}



pFgivenCountsSNPs <- function(c, r, group, epsilon = 1 / 100, f = 0.5) {
  # this omputes the posterior probabily of a value of f for individual SNPs, using snp
  # group information instead of c1, r1, c2, r2 (as r1 or r2 = 0 for a single
  # SNP)
  # c, r and group are integer vectors
  Nominator <- vapply(Fset, function(Fset) {
    dbinom(c, size = r, prob = ifelse(
      group == 1L,
      yes = Fset,
      no = (1 - epsilon) * (0.5 - Fset) + epsilon
    ))
  }, numeric(length(c)))
  
  # the posterior for each possible value of f
  p <- Nominator / rowSums(Nominator)
  
  # we return the probability for the value of f we want
  p[, Fset == f]
}


pLimit <- function(p) {
  # computes the limit of the log(p05) "p" above which SNPs are considered as outlier
  if (length(p) == 1L) {
    return(p)
  }
  excluded <- F
  repeat {
    limit <- mean(p[!excluded]) + 4 * sd(p[!excluded])
    newExcluded <- p > limit & !excluded
    if (!any(newExcluded)) {
      return(limit)
    }
    excluded <- newExcluded | excluded
  }
}



pFgivenCountsHapl <- function(c1, r1, c2, r2, epsilon = 0.01) {
  # computes the posterior probabilities of haplotype frequencies given read counts (integer vectors, one value per contig)

  Nominator <- t(vapply(
    Fset,
    function(f) dbinom(c1, r1, f) * dbinom(c2, r2, (1 - epsilon) * (0.5 - f) + epsilon),
    # see script 03 for a explanation as to why we use the same function for both sexes
    numeric(length(c1))
  ))

  if (nrow(Nominator) == 1L) Nominator <- t(Nominator)
  t(Nominator) / colSums(Nominator)
}


# some functions used for plotting ----------------------------------

closedPolygon <- function(x, y, closeAt = 0L, ...) {
  # convenience function to closes a polygon at a certain Y value
  x <- c(x[1], x, tail(x, 1))
  y <- c(closeAt, y, closeAt)
  polygon(x, y, ...)
}

densityPolygon <- function(x, Yscale = 1, col = NA, border = NULL, lty = par("lty"), ...) {
  # convenience function to plot density with a polygon
  d <- density(x, ...)
  closedPolygon(x = d$x, y = d$y * Yscale, col = col, border = border, lty = lty)
}

ggstyle <- function(...) {
  # sets graphical parameters similar to those of ggplot2
  par(bty = "n", lend = 1, cex.axis = 0.8, tcl = -0.2, mgp = c(1.5, 0.3, 0), ...)
}

ggBackground <- function(
                         x, y = NULL, main = "", axes = T, xaxt = par("xaxt"), yaxt = par("yaxt"),
                         xgrid = T, ygrid = T, las = 1, bg.col = grey(0.92), grid.lwd = 1.5, subgrid.lwd = 0.5, ...) {
  # prepares a plot background mimicking the ggplot2 style.
  # this may sometimes be more convenient than using ggplot istelf

  ggstyle()

  if (!is.vector(x)) {
    y <- as.matrix(x)[, 2]
    x <- as.matrix(x)[, 1]
  }

  plot(x, y, axes = F, main = main, type = "n", las = las, ...)
  do.call(rect, c(as.list(par("usr")[c(1, 3, 2, 4)]), col = bg.col, border = NA))

  ticks <- par("xaxp")
  step <- (ticks[2] - ticks[1]) / ticks[3]
  mainXTicks <- seq(ticks[1], ticks[2], length.out = ticks[3] + 1)

  if (xgrid) {
    abline(v = mainXTicks, col = "white", lwd = grid.lwd)
    secondaryTicks <- setdiff(seq(ticks[1] - step, ticks[2] + step, step / 2), mainXTicks)
    secondaryTicks <- secondaryTicks[secondaryTicks > par("usr")[1] & secondaryTicks < par("usr")[2]]
    abline(v = secondaryTicks, col = "white", lwd = subgrid.lwd)
  }

  ticks <- par("yaxp")
  step <- (ticks[2] - ticks[1]) / ticks[3]
  mainYTicks <- seq(ticks[1], ticks[2], length.out = ticks[3] + 1)

  if (ygrid) {
    abline(h = mainYTicks, col = "white", lwd = grid.lwd)
    secondaryTicks <- setdiff(seq(ticks[1] - step, ticks[2] + step, step / 2), mainXTicks)
    secondaryTicks <- secondaryTicks[secondaryTicks > par("usr")[3] & secondaryTicks < par("usr")[4]]
    abline(h = secondaryTicks, col = "white", lwd = subgrid.lwd)
  }

  if (axes) {
    if (xaxt != "n") axis(1, mainXTicks, col = NA, col.ticks = 1, col.axis = grey(0.3), las = las, lwd = grid.lwd)
    if (yaxt != "n") axis(2, mainYTicks, col = NA, col.ticks = 1, col.axis = grey(0.3), las = las, lwd = grid.lwd)
  }
}


# functions related to recombination analysis -----------------------------------


countHapl <- function(hapl) {
  # counts the number of different 2-SNP haplotypes
  # the argument is a matrix where columns = individuals
  # and values = 2-digit numbers indicate the haplotype

  hapl <- hapl + 1:nrow(hapl) * 100
  hapl <- unique(as.vector(hapl))
  nHapl <- tabulate(as.integer(hapl / 100))
}


breakPoints <- function(gen, plot = F, symmetric = T, diag = T) {
  # returns the position of first and last SNPs of genomic blocks of a contig
  # gen is a data table of parental genotype + SNP positions
  # a plot (cf figure S6) can be made on demand (last 3 arguments)

  # if there is less than 2 SNPs per contig, we return the SNP position
  if (nrow(gen) < 2L) {
    return(gen[, genomePos + 0:1])
  }
  nr <- nrow(gen)

  # we generate all pairs of SNPs (removing reciprocity)
  # a SNP here is designated by its row in the gen table
  pairs <- setNames(data.table(expand.grid(1:nr, 1:nr)), c("SNP1", "SNP2"))
  pairs <- pairs[SNP1 < SNP2]

  # we retrieve the genotypes for all SNPs of the pairs
  gen1 <- as.matrix(gen[pairs$SNP1, -(1:3), with = F])
  gen2 <- as.matrix(gen[pairs$SNP2, -(1:3), with = F])

  # we generate the haplotype for each pair, as a 2-digit number
  hapl <- gen1 * 10L + gen2

  # we test if each father is heterozygous a both SNPs
  hetXfather <- gen1[, 3] != gen1[, 4] & gen2[, 3] != gen2[, 4]
  hetYfather <- gen1[, 7] != gen1[, 8] & gen2[, 7] != gen2[, 8]

  # in which case, we ignore its haplotype
  hapl[hetXfather, 3:4] <- NA
  hapl[hetYfather, 7:8] <- NA

  # we count the different haplotype for each SNP pair
  nHapl <- countHapl(hapl)

  # if there are 4 haplotypes, the two SNPs must have recombined
  recomb = pairs[nHapl == 4L]
  
  # we delineate recombination blocks
  # for this, we do a trick. We make as if each SNP1 has recombined
  # with a SNP2 that is after the last SNP of the contig
  recomb2 <- rbind(data.table(SNP1 = 1:nr, SNP2 = nr + 1L), recomb)
  setorder(recomb2, SNP1, SNP2)
  recomb2 <- recomb2[!duplicated(SNP1)]

  # we determine the intial start and end position of blocks
  # this is a bit abstract to explain, so one should run this to see
  # how it works
  start <- recomb2$SNP1
  end <- recomb2$SNP2 - 1L
  l <- length(start)
  for (i in 2:l - 1L) end[i] <- min(end[i:l])
  noDup <- !duplicated(end)
  start <- start[noDup]
  end <- end[noDup]

  # we remove overlaps between blocks by shortening the shorter blocks
  if (sum(noDup) > 1L) {
    overlaps <- rep(T, length(start))

    while (any(overlaps)) {
      longest <- which.max((end - start + 1L) * overlaps)
      overlaps[longest] <- F
      overlapLeft <- end >= start[longest] & end <= end[longest] & overlaps
      end[overlapLeft] <- start[longest] - 1L

      overlapRight <- start <= end[longest] & start >= start[longest] & overlaps
      start[overlapRight] <- end[longest] + 1L
      overlaps[end < start] <- F
    }
  }

  breaks <- data.table(start, end)
  breaks <- breaks[start <= end, ]

  # we plot the results as an image
  if (plot) {
    # we prepare a square logical matrix for the image
    # by default, it has NAs (white)
    mat <- matrix(NA, nrow = nr, ncol = nr)
    mat[as.matrix(recomb)] <- T
    if (symmetric) mat[as.matrix(recomb[, .(SNP2, SNP1)])] <- T

    # we plot the SNP type (column "rec") on the diagonal
    if (diag) diag(mat) <- gen$rec

    # the instruction below is to ensure that colors are what we want
    r <- range(mat, na.rm = T)

    image(
      x = 1:nr, y = 1:nr, mat, main = gen$CHROM[1],
      col = c("red", "grey", "forestgreen", "green", "orange", "violet")[r[1]:r[2]],
      xlab = "SNP number", ylab = "SNP number"
    )

    # we draw blocks as rectangles
    b <- breaks[, rect(
      xleft = start - 0.5, ybottom = start - 0.5,
      xright = end + 0.5, ytop = end + 0.5, border = "black"
    )]
  }

  # we return the genomic positions of SNPs at the end of blocks
  # as an integer vector (the end position is the SNP position + 1L)
  res <- gen[, c(genomePos[breaks$start], genomePos[breaks$end] + 1L)]
}


intersectsRanges <- function(ranges, ranges2, returnLength = F) {
  # returns the number of positions (an integer) for which each range of
  # "ranges" intersect any range of ranges2. Ranges are data.frames in bed-like
  # format with closed intervals

  ranges <- as.data.table(ranges)
  setnames(ranges, 1:3, c("scaffold", "start", "end"))

  # to keep track of the ranges by their rows
  nums <- 1:nrow(ranges)
  ranges2 <- as.data.table(ranges2)
  setnames(ranges2, 1:3, c("scaffold", "start", "end"))

  # "melts" the ranges and put all starts and ends in the same colums. intervals
  # of ranges1 are given integer numbers >=1  "c" will be useful to compute
  # coverage (+1 when a range starts, -1 when it ends)
  allRanges <- data.table(
    scaffold = rep(c(ranges$scaffold, ranges2$scaffold), 2),
    pos = c(ranges$start, ranges2$start, ranges$end, ranges2$end),
    n = rep(c(nums, rep(0L, nrow(ranges2))), 2),
    c = rep(c(1L, -1L), each = nrow(ranges) + nrow(ranges2))
  )

  setorder(allRanges, scaffold, pos, -c)

  # computes coverage at a given position (start or end of range). Coverage
  # increases by 1 at earch start and decreases by 1 and each end. Note that
  # this considers all ranges (not just ranges2)
  allRanges[, cov := cumsum(c)]

  # to compute coverage while ignoring ranges2
  allRanges[n == 0L, c := 0L]

  # cov2 ignores ranges2
  allRanges[, cov2 := cumsum(c)]

  # so we can flag positions of overlaps between ranges and ranges2 when the two
  # coverages differ and when cov2 is positive
  allRanges[, overlap := cov > cov2 & cov2 > 0L]

  # rows where ranges start and end
  starts <- match(nums, allRanges$n)
  ends <- matchLast(nums, allRanges$n)

  # same, but excluding ranges2
  starts2 <- match(nums, allRanges[n > 0L, n])
  ends2 <- matchLast(nums, allRanges[n > 0L, n])

  # so we can obtain ranges that overlap with ranges2
  f <- (ends - starts > ends2 - starts2) | allRanges[starts, overlap]
  if (!returnLength) {
    return(f)
  }

  # to compute lenght of overlaps, we remove non-intersecting ranges from the table
  allRanges <- allRanges[n %in% c(0L, nums[f])]

  # and we re-obtain first and last rows for each intersecting range
  starts <- match(nums[f], allRanges$n)
  ends <- matchLast(nums[f], allRanges$n)

  # so we can generate all the rows that each range covers in the allRanges table
  v <- unlist(Map(":", starts, ends))

  # this allows creating a table that list all the rows covered by each range,
  # repeating rows if needed
  dt <- allRanges[v, .(overlap, pos, n2 = n, n = rep(nums[f], ends - starts + 1L))]


  # for a given range, we're only intested in positions related to starts/ends
  # of ranges2 or the end/start or this range (where n2 == n).
  dt <- dt[n2 == 0L | n2 == n, ]

  # at the end of each range, we consider that the overlap is ended
  # (effectively, it is, since the range ends there)
  dt[!duplicated(n, fromLast = T), overlap := F]
  row <- 2:nrow(dt)

  # we remove successive rows where the overlap value doesn't change (positions
  # that don't create/end overlaps). In the end, each row starting and overlap
  # will be followed by one ending the overlap
  redundant <- dt[, c(F, overlap[row] == overlap[row - 1L] & n[row] == n[row - 1L])]
  dt <- dt[!(redundant | (!duplicated(n) & !overlap))]

  # rows where overlaps start
  starts <- which(dt$overlap)

  # so we can generaate overlap blocks for each range
  blocks <- dt[, .(n = n[starts], start = pos[starts], end = pos[starts + 1L])]

  # and use these blocks to compute the total length of overlaps for each range
  perR <- blocks[, sum(end - start + 1L), by = n]

  # intersect will be this length (an interger vector)
  intersect <- integer(nrow(ranges))
  intersect[perR$n] <- perR$V1
  intersect
}


numericClass <- function(x, size) {
  # required by the function below
  as.integer(ceiling(x / size)) * size
}


# two functions related to sliding windows

slidingWindows <- function(pos, size, step = size) {
  # for each numeric position of a vector (pos), returns the window it belongs to
  # (this will be the midpoint of the window).  The step is the distance between
  # successive windows. If windows are overlapping, returns a matrix in which
  # elements of the same row correspond to windows covering the same position

  # number of windows covering a position
  n <- as.integer(ceiling(size / step))

  vapply(
    1:n - 1L,
    function(x) numericClass(pos - x * step, size) + x * step - as.integer(size / 2),
    integer(length(pos))
  )
}



plotContig <- function(cont, depth, gff, SNPs) {
  # plot sequencing depths and other information related to a contig (cont) for figure 7
  
  # we select the sequencing depth data we need (we discard windows that are too short)
  sub <- depth[contig == cont & N >= 500L, ]
  
  # we leave some margin below 0 to plot the genes as horizontal segments
  maxDepth = sub[,max(dWXA, sWXA, dZM, sZM)]
  plotBottom = 0-maxDepth /8
  
  # we prepare an empty plot 
  # (we don't draw curves yet as we first draw rectangles and SNPs, see below)
  with(sub, matplot(
    x = window, 
    y = cbind(dWXA, sWXA, dZM, sZM, dBF, sBF), 
    main = cont, xlab = "", bty = "n", type ="n",las = 1, 
    ylab = "normalized sequencing depth", ylim = c(plotBottom, maxDepth)
    ))
  
  # we show low-CQ regions with rectangles
  p = blocks[contig == cont, rect(
    xleft = start, ybottom = 0, xright = end, ytop = par("usr")[4], 
    col = rgb(1, 0.9, 0.9), border = NA
    )]
  
  # we plot SNPs as vertical segments
  snps = SNPs[CHROM == cont] ; setorder(snps, rec)
  p <- snps[, segments(
    x0 = POS, y0 = 0, y1 = par("usr")[4], lwd = 1, lend =1,
    col = c("grey", "grey", "darkgreen", "green")[rec]
    )]
  
  # we draw the sequencing depth curves. Colors mimmick those on figure 1
  with(sub, matplot(
    x = window, y = cbind(dWXA, sWXA, dZM, sZM, dBF, sBF), type = "l", add =T, 
    col = c(rgb(200/255,42/255,23/255), rgb(51/255,117/255, 181/255)), lty = 1, lwd = 2
    ))
  
  
  # we plot gene as horizontal segments
  Y = plotBottom
  if (gff[contig == cont, any(type == "gene")]) {
    s <- gff[contig == cont & type == "gene", segments(start, Y, end, Y, col = grey(0.3), lend =1, lwd = 2)]
    s <- gff[contig == cont & type == "gene", text(mid, Y, gene, cex = 0.9, col = grey(0.3), pos = 3)]
    s <- gff[contig == cont & type == "exon", segments(start, Y, end, Y, col = "red", lend = 1, lwd = 6)]
  }
}

